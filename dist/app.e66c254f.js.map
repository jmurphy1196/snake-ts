{"version":3,"sources":["Snake.ts","Draw.ts","Fruit.ts","app.ts"],"names":[],"mappings":"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","file":"app.e66c254f.js","sourceRoot":"..\\src","sourcesContent":["import { FruitsI, DrawI } from \"./types\";\r\nexport default class Snake {\r\n  direction: string;\r\n  xSpeed: number;\r\n  ySpeed: number;\r\n  color: string;\r\n  nodes: Array<SnakeNode>;\r\n  size: number;\r\n  scale: number;\r\n  private CAN_CHANGE_DIRECTIONS: boolean = true;\r\n  constructor(scale: number, color = \"white\") {\r\n    this.xSpeed = scale * 1;\r\n    this.ySpeed = scale * 1;\r\n    this.color = color;\r\n    this.nodes = [new SnakeNode(0, 0, scale * 32)];\r\n    this.direction = \"right\";\r\n    this.size = 32 * scale;\r\n    this.scale = scale;\r\n  }\r\n\r\n  print() {\r\n    console.log(this.nodes);\r\n  }\r\n  setNewPosition(columns: number, rows: number) {\r\n    const snakeHead = this.nodes[this.nodes.length - 1];\r\n    let prevX = snakeHead.x;\r\n    let prevY = snakeHead.y;\r\n    const followTheHead = () => {\r\n      for (let i = this.nodes.length - 2; i >= 0; i--) {\r\n        let temp = this.nodes[i].x;\r\n        let temp2 = this.nodes[i].y;\r\n        this.nodes[i].x = prevX;\r\n        this.nodes[i].y = prevY;\r\n        prevX = temp;\r\n        prevY = temp2;\r\n      }\r\n    };\r\n    switch (this.direction) {\r\n      case \"right\":\r\n        snakeHead.x += snakeHead.size;\r\n        if (snakeHead.x + this.size / 2 > columns) snakeHead.x = 0;\r\n\r\n        break;\r\n      case \"down\":\r\n        snakeHead.y += snakeHead.size;\r\n        if (snakeHead.y + this.size / 2 > rows) snakeHead.y = 0;\r\n        break;\r\n      case \"left\":\r\n        snakeHead.x -= snakeHead.size;\r\n        if (snakeHead.x + this.size / 2 < 0)\r\n          snakeHead.x = columns - snakeHead.size;\r\n\r\n        break;\r\n      case \"up\":\r\n        snakeHead.y -= snakeHead.size;\r\n        if (snakeHead.y + this.size / 2 < 0)\r\n          snakeHead.y = rows - snakeHead.size;\r\n        break;\r\n    }\r\n    followTheHead();\r\n  }\r\n  delete() {\r\n    this.nodes = [];\r\n    this.nodes.push(new SnakeNode(0, 0, this.size * this.scale));\r\n  }\r\n  checkCollisionWithSelf() {\r\n    const snakePositions = {};\r\n    let didCollide = false;\r\n    this.nodes.forEach((node, i) => {\r\n      if (snakePositions[`${node.x},${node.y}`]) {\r\n        didCollide = true;\r\n      } else {\r\n        snakePositions[`${node.x},${node.y}`] = i;\r\n      }\r\n    });\r\n\r\n    return didCollide;\r\n  }\r\n  changeDirections(key: string) {\r\n    if (this.CAN_CHANGE_DIRECTIONS) {\r\n      switch (key) {\r\n        case \"w\":\r\n          this.direction = \"up\";\r\n          break;\r\n        case \"d\":\r\n          this.direction = \"right\";\r\n          break;\r\n        case \"a\":\r\n          this.direction = \"left\";\r\n          break;\r\n        case \"s\":\r\n          this.direction = \"down\";\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  insert() {\r\n    const snakeHead = this.nodes[this.nodes.length - 1];\r\n    let newNode;\r\n    switch (this.direction) {\r\n      case \"right\":\r\n        newNode = new SnakeNode(\r\n          snakeHead.x + snakeHead.size,\r\n          snakeHead.y,\r\n          snakeHead.size\r\n        );\r\n        break;\r\n      case \"down\":\r\n        newNode = new SnakeNode(\r\n          snakeHead.x,\r\n          snakeHead.y + snakeHead.size,\r\n          snakeHead.size\r\n        );\r\n        break;\r\n      case \"left\":\r\n        newNode = new SnakeNode(\r\n          snakeHead.x - snakeHead.size,\r\n          snakeHead.y,\r\n          snakeHead.size\r\n        );\r\n        break;\r\n      case \"up\":\r\n        newNode = new SnakeNode(\r\n          snakeHead.x,\r\n          snakeHead.y - snakeHead.size,\r\n          snakeHead.size\r\n        );\r\n        break;\r\n    }\r\n\r\n    this.nodes.push(newNode);\r\n  }\r\n}\r\n\r\nclass SnakeNode {\r\n  constructor(public x: number, public y: number, public size: number) {}\r\n}\r\n","import { FruitsI, SnakeI } from \"./types\";\r\nexport default class Draw {\r\n  ctx: CanvasRenderingContext2D;\r\n  rows: number;\r\n  columns: number;\r\n  canvas: HTMLCanvasElement;\r\n  constructor(public scale: number, canvas: HTMLCanvasElement) {\r\n    this.ctx = canvas.getContext(\"2d\");\r\n    this.rows = canvas.height * scale;\r\n    this.columns = canvas.width * scale;\r\n    this.canvas = canvas;\r\n    canvas.width *= scale;\r\n    canvas.height *= scale;\r\n  }\r\n\r\n  drawSnake(snakeObj: SnakeI) {\r\n    snakeObj.nodes.forEach((node) => {\r\n      this.ctx.beginPath();\r\n      this.ctx.rect(node.x, node.y, node.size, node.size);\r\n      this.ctx.fillStyle = snakeObj.color;\r\n      this.ctx.fill();\r\n    });\r\n  }\r\n  drawFruit(fruits: FruitsI[]) {\r\n    fruits.forEach((fruit) => {\r\n      this.ctx.beginPath();\r\n      this.ctx.rect(fruit.x, fruit.y, fruit.size, fruit.size);\r\n      this.ctx.fillStyle = fruit.color;\r\n      this.ctx.fill();\r\n    });\r\n  }\r\n  drawBoard(snake: SnakeI, fruits: FruitsI[]) {\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.drawSnake(snake);\r\n    this.drawFruit(fruits);\r\n  }\r\n\r\n  randomPoints() {\r\n    //TODO fix this -> sometimes will spawn fruit outside map edge\r\n    const randomX = Math.floor(Math.random() * this.columns - 45);\r\n    const randomY = Math.floor(Math.random() * this.rows - 45);\r\n    return [randomX, randomY];\r\n  }\r\n}\r\n","export class Fruit {\r\n  x: number;\r\n  y: number;\r\n  color: string;\r\n  size: number = 32;\r\n  constructor(x: number, y: number, scale = 1, color = \"orange\") {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.color = color;\r\n    this.size = 45;\r\n  }\r\n}\r\n","import Snake from \"./Snake\";\r\nimport Draw from \"./Draw\";\r\nimport { Fruit } from \"./Fruit\";\r\n\r\nconst game_1_root: HTMLElement = document.querySelector(\".root\");\r\nclass Game {\r\n  private GAME_SPEED = 110;\r\n  canvas: HTMLCanvasElement;\r\n  root: HTMLElement;\r\n  screen: Draw;\r\n  snake: Snake;\r\n  fruits: Fruit[];\r\n  scale: number;\r\n  score: number;\r\n  constructor(root: HTMLElement, scale: number) {\r\n    //setup the canvas\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.style.backgroundColor = \"grey\";\r\n    canvas.width = 640;\r\n    canvas.height = 480;\r\n    this.canvas = canvas;\r\n    this.root = root;\r\n    this.root.appendChild(canvas);\r\n    this.scale = scale;\r\n    this.score = 0;\r\n\r\n    //setup the screen\r\n    this.screen = new Draw(scale, canvas);\r\n    this.snake = new Snake(this.screen.scale, \"#cfdac8\");\r\n    this.fruits = [];\r\n  }\r\n  checkCollisionFruit() {\r\n    let collided = false;\r\n    let snakeHead = this.snake.nodes[this.snake.nodes.length - 1];\r\n    let fruitIndex;\r\n    this.fruits.forEach((fruit, i) => {\r\n      if (\r\n        snakeHead.x >= fruit.x - snakeHead.size / 2 &&\r\n        snakeHead.x <= fruit.x + snakeHead.size / 2 &&\r\n        snakeHead.y >= fruit.y - snakeHead.size / 2 &&\r\n        snakeHead.y <= fruit.y + snakeHead.size / 2\r\n      ) {\r\n        collided = true;\r\n        fruitIndex = i;\r\n      }\r\n    });\r\n    if (collided) {\r\n      return fruitIndex;\r\n    }\r\n    return undefined;\r\n  }\r\n  drawScore() {\r\n    const scoreElement: HTMLElement = document.getElementById(\"score\");\r\n    if (scoreElement) {\r\n      scoreElement.innerHTML = `SCORE: ${this.score}`;\r\n    }\r\n  }\r\n\r\n  start() {\r\n    this.drawScore();\r\n    //variables\r\n    let CAN_GET_DIRECTIONS = true;\r\n\r\n    // add event listener\r\n    window.addEventListener(\"keypress\", (e) => {\r\n      this.snake.changeDirections(e.key);\r\n    });\r\n    //draw the snake\r\n    this.screen.drawSnake(this.snake);\r\n\r\n    setInterval(() => {\r\n      if (this.fruits.length < 5) {\r\n        const [fruitX, fruitY] = this.screen.randomPoints();\r\n        const fruit = new Fruit(fruitX, fruitY, 40 * this.scale, \"orange\");\r\n        this.fruits.push(fruit);\r\n      }\r\n    }, 5000);\r\n\r\n    setInterval(() => {\r\n      this.snake.setNewPosition(this.screen.columns, this.screen.rows);\r\n      const fruitCollided = this.checkCollisionFruit();\r\n      if (fruitCollided || fruitCollided === 0) {\r\n        //handle collision\r\n        this.snake.insert();\r\n        this.fruits = this.fruits.filter((fruit, i) => i !== fruitCollided);\r\n        this.score += 1;\r\n        this.drawScore();\r\n      }\r\n      const collidedWithSelf = this.snake.checkCollisionWithSelf();\r\n      if (collidedWithSelf) {\r\n        console.log(\"game over!\");\r\n        this.reset();\r\n      }\r\n      this.screen.drawBoard(this.snake, this.fruits);\r\n    }, this.GAME_SPEED);\r\n  }\r\n  reset() {\r\n    this.score = 0;\r\n    this.snake.delete();\r\n    this.fruits = [];\r\n    this.drawScore();\r\n  }\r\n}\r\n\r\nconst game = new Game(game_1_root, 1.3);\r\ngame.start();\r\n"]}